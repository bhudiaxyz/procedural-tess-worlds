import AbstractGenerator from "./AbstractGenerator";


export default class AbstractPlanetGenerator extends AbstractGenerator {

  constructor(random, noise, config_props) {
    super();

    this.random = random;
    this.simplex = noise;

    this.lacunarity = config_props.lacunarity;
    this.persistance = config_props.persistance;
    this.octaves = config_props.octaves;

    // Set color of mesh face based on height of face compared to the face with max height
    this.terrainType = {
      mountainTop: {threshold: 0.87, color: 0xe6ebea},  // 0xC8C8C8
      darkMountain: {threshold: 0.85, color: 0x735B5B},
      mountain: {threshold: 0.76, color: 0x826868},
      grass: {threshold: 0.60, color: 0x00FF00},
      darkGrass: {threshold: 0.57, color: 0x1FBA04},
      sand: {threshold: 0.47, color: 0xC4B572},
      water: {threshold: 0.00, color: 0x3CB0D6}
    };
  }

  generate(props) {
    // Abstract - generate
  }

  //==================
  // HELPER FUNCTIONS
  //==================

  // Gets value of 3D simplex noise at a vertex
  getNoiseValue(vertex, scale) {
    let amplitude = 1;
    let frequency = 1;
    let value = 0;
    for (let i = 0; i < this.octaves; i++) {
      value += amplitude * this.simplex.noise3D(frequency * vertex.x / scale, frequency * vertex.y / scale, frequency * vertex.z / scale);
      amplitude *= this.persistance;
      frequency *= this.lacunarity;
    }
    return value;
  }

  // Map values (in_min, in_max) to (out_min, out_max)
  rescale(val, in_min, in_max, out_min, out_max) {
    return (val - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
  }


  // Returns min, max values generated by noise
  getMinMaxValues(vertices, planetSize) {
    let maxValue = Number.MIN_VALUE;
    let minValue = Number.MAX_VALUE;
    for (let i = 0; i < vertices.length; i++) {
      let vertex = vertices[i];
      let value = this.getNoiseValue(vertex, planetSize / 2);
      maxValue = Math.max(maxValue, value);
      minValue = Math.min(minValue, value);
    }
    return {minValue, maxValue};
  }

  setFaceColor(heightPercent, face) {
    if (heightPercent > this.terrainType.mountainTop.threshold) {
      face.color.set(this.terrainType.mountainTop.color);
    } else if (heightPercent > this.terrainType.darkMountain.threshold) {
      face.color.set(this.terrainType.darkMountain.color);
    } else if (heightPercent > this.terrainType.mountain.threshold) {
      face.color.set(this.terrainType.mountain.color);
    } else if (heightPercent > this.terrainType.grass.threshold) {
      face.color.set(this.terrainType.grass.color);
    } else if (heightPercent > this.terrainType.darkGrass.threshold) {
      face.color.set(this.terrainType.darkGrass.color);
    } else if (heightPercent > this.terrainType.sand.threshold) {
      face.color.set(this.terrainType.sand.color);
    } else if (heightPercent > this.terrainType.water.threshold) {
      face.color.set(this.terrainType.water.color);
    }
  }

  // Create mesh from polygon for flat-height tile terrain
  createPolygonMesh(planetGeometry, polygon, height) {
    let geometry = new THREE.Geometry();
    let vertices = planetGeometry.vertices;

    // Top vertices of cylinder
    for (let i = 0; i < polygon.length; i++) {
      let vertexIndex = polygon[i];
      geometry.vertices.push(vertices[vertexIndex].clone().multiplyScalar(height));
    }

    // Bottom vertices of cylinder
    for (let i = 0; i < polygon.length; i++) {
      let vertexIndex = polygon[i];
      geometry.vertices.push(vertices[vertexIndex].clone());
    }

    if (polygon.length === 6) {
      // Top faces
      geometry.faces.push(new THREE.Face3(0, 1, 2));
      geometry.faces.push(new THREE.Face3(0, 2, 3));
      geometry.faces.push(new THREE.Face3(0, 3, 4));
      geometry.faces.push(new THREE.Face3(0, 4, 5));
      geometry.faces.push(new THREE.Face3(0, 5, 1));

      // Bottom faces
      geometry.faces.push(new THREE.Face3(6, 7, 8));
      geometry.faces.push(new THREE.Face3(6, 8, 9));
      geometry.faces.push(new THREE.Face3(6, 9, 10));
      geometry.faces.push(new THREE.Face3(6, 10, 11));
      geometry.faces.push(new THREE.Face3(6, 11, 7));

      // Body faces (one tessellation)
      geometry.faces.push(new THREE.Face3(1, 7, 2));
      geometry.faces.push(new THREE.Face3(2, 7, 8));
      geometry.faces.push(new THREE.Face3(2, 8, 3));
      geometry.faces.push(new THREE.Face3(3, 8, 9));
      geometry.faces.push(new THREE.Face3(3, 9, 4));
      geometry.faces.push(new THREE.Face3(4, 9, 10));
      geometry.faces.push(new THREE.Face3(4, 10, 5));
      geometry.faces.push(new THREE.Face3(5, 10, 11));
      geometry.faces.push(new THREE.Face3(5, 11, 1));
      geometry.faces.push(new THREE.Face3(1, 11, 7));
    } else {
      // Top faces
      geometry.faces.push(new THREE.Face3(0, 1, 2));
      geometry.faces.push(new THREE.Face3(0, 2, 3));
      geometry.faces.push(new THREE.Face3(0, 3, 4));
      geometry.faces.push(new THREE.Face3(0, 4, 5));
      geometry.faces.push(new THREE.Face3(0, 5, 6));
      geometry.faces.push(new THREE.Face3(0, 6, 1));

      // Bottom faces
      geometry.faces.push(new THREE.Face3(7, 8, 9));
      geometry.faces.push(new THREE.Face3(7, 9, 10));
      geometry.faces.push(new THREE.Face3(7, 10, 11));
      geometry.faces.push(new THREE.Face3(7, 11, 12));
      geometry.faces.push(new THREE.Face3(7, 12, 13));
      geometry.faces.push(new THREE.Face3(7, 13, 8));

      // Body faces (one tessellation)
      geometry.faces.push(new THREE.Face3(1, 8, 2));
      geometry.faces.push(new THREE.Face3(2, 8, 9));
      geometry.faces.push(new THREE.Face3(2, 9, 3));
      geometry.faces.push(new THREE.Face3(3, 9, 10));
      geometry.faces.push(new THREE.Face3(3, 10, 4));
      geometry.faces.push(new THREE.Face3(4, 10, 11));
      geometry.faces.push(new THREE.Face3(4, 11, 5));
      geometry.faces.push(new THREE.Face3(5, 11, 12));
      geometry.faces.push(new THREE.Face3(5, 12, 6));
      geometry.faces.push(new THREE.Face3(6, 12, 13));
      geometry.faces.push(new THREE.Face3(6, 13, 1));
      geometry.faces.push(new THREE.Face3(1, 13, 8));
    }

    return geometry;
  }
}
